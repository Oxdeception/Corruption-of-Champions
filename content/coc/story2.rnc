
start = mod
# #############################################
# mod structure
mod = element mod {
    attribute name { text },
    attribute version { text }?,
    import*,
    state?,
    hook*,
#    export*,
    exportable*
}
import = element import {
    attribute ref { text }
}
state = element state {
    var*
}
hook = element hook {
    attribute type { 'daily' | 'hourly' },
    content*
}
var = element var {
    attribute name { text },
    (text | empty)
}
#export = element export {
#    attribute ref { text }
#}
exportable = monster | lib | Text | scene
lib = element lib {
    attribute name { text },
    exportable*
}
Text = element text {
    attribute name { text },
    content*
}
scene = element scene {
    attribute name { text },
    content*
}

# #############################################
# monster
monster = element monster {
    attribute id { text },
    attribute base { text }?,
    element name { content }?,
    element desc { content }?,
    element plural { empty }?,
    element a { content }?,
    element pronouns {
        attribute he { text },
        attribute his { text },
        attribute him { text }
    }?,
    monsterBody?,
    monsterCombat?,
    script*
}
script = element script {
    attribute language { 'lua' | text }?,
    text
}
monsterBody = element body {
    element vagina {
        attribute virgin { 'true' | 'false' }?,
        attribute wetness { text }?,
        attribute looseness { text }?
    }?,
    element breasts { text }?,
    element anal {
        attribute looseness { text }?,
        attribute wetness { text }?
    }?,
    element height { text }?,
    element hips { text }?,
    element butt { text }?,
    element skin {
        attribute coverage { text },
        element base {
            skinLayer
        }?,
        element coat {
            skinLayer
        }?
    }?,
    element hair {
        attribute length { text }?,
        attribute color { text }?,
        attribute type { text }?
    }?,
    element antennae { text }?,
    element arms { text }?,
    element beard {
        attribute type { text }?,
        attribute length { text }?
    }?,
    element claws {
        attribute type { text }?,
        attribute color { text }?
    }?,
    element ears { text }?,
    element eyes {
        attribute type { text }?,
        attribute count { text }?,
        attribute color { text }?
    }?,
    element face { text }?,
    element gills { text }?,
    element horns {
        attribute type { text }?,
        attribute count { text }?
    }?,
    element legs {
        attribute type { text }?,
        attribute count { text }?
    }?,
    element rearBody { text }?,
    element tail {
        attribute type { text }?,
        attribute count { text }?
    }?,
    element tongue { text }?,
    element wings { text }?
}
skinLayer = (
    attribute type { text }?,
    attribute color { text }?,
    attribute color2 { text }?,
    attribute pattern { text }?,
    attribute adj { text }?,
    attribute desc { text }?
)
monsterCombat = element combat {
    element level { text }?,
    element str { text }?,
    element tou { text }?,
    element spe { text }?,
    element int { text }?,
    element wis { text }?,
    element lib { text }?,
    element sen { text }?,
    element cor { text }?,
    element weapon {
        attribute name { text }?,
        attribute verb { text }?,
        attribute attack { text }?
    }?,
    element armor {
        attribute name { text }?,
        attribute defense { text }?
    },
    element bonusHP { text }?,
    element loot {
        loot
    }?
}
loot = element item { text }

# #############################################
# textual content
content =
    text | b | i | font | if | switch | xcc-content
b = element b { content* }
i = element i { content* }
font = element font {
    attribute color { text }?,
    content*
}
#xcc-named-content = Text | String | lib | story | macro | extend-story | zone | extend-zone
xcc-content = display | set # | xcc-named-content | | dynStats | output | Include
#namedBlock = attribute name { text }?, content*
#String = element string { namedBlock }
set = element set {
    attribute var { text },
    attribute value { expression }?,
    attribute op { 'append' | 'set' | 'add' | "+=" | '=' }?,
    text*
}
display = element display {
    attribute ref { text },
    empty
}
#extend-story = element extend-story { namedBlock }
#zone = element zone {
#    namedBlock,
#    encounter*
#}
#extend-zone = element extend-zone {
#    namedBlock,
#    encounter*
#}
#encounter = element encounter {
#    attribute name { text },
#    attribute chance { expression }?,
#    attribute when { expression }?,
#    content*
#}
#dynStats = element dynStats {
#    attribute str { expression }?,
#    attribute tou { expression }?,
#    attribute spe { expression }?,
#    attribute int { expression }?,
#    attribute lib { expression }?,
#    attribute sen { expression }?,
#    attribute lus { expression }?,
#    attribute cor { expression }?,
#    attribute scale { expression }?,
#    empty
#}
#output = element output { expression }
#Include = element include {
#    attribute path { text },
#    attribute required { "true" | "false" }?,
#    empty
#}

# #############################################
# xlogic
expression = text
array-content-expression = text
if = element if {
    attribute test { expression },
    (if-big | if-short)
}
if-big = (
    content*,
    elseif*,
    else?
)
if-short = (
    empty,
    attribute then { text },
    attribute else { text }?
)
elseif = (
    element elseif {
        attribute test { expression }
    },
    content*
)
else = (
    element else { empty },
    content*
)
switch = element switch {
    attribute value { expression }?,
    case*,
    Default?
}
case = element case {
    attribute test { expression }?,
    attribute value { expression }?,
    attribute values { array-content-expression }?,
    attribute lt { expression }?,
    attribute gt { expression }?,
    attribute ne { expression }?,
    attribute lte { expression }?,
    attribute gte { expression }?,
    content*
}
Default = element default {
    content*
}
